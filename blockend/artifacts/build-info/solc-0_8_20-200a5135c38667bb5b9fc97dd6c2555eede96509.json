{
  "_format": "hh3-sol-build-info-1",
  "id": "solc-0_8_20-200a5135c38667bb5b9fc97dd6c2555eede96509",
  "solcVersion": "0.8.20",
  "solcLongVersion": "0.8.20+commit.a1b79de6",
  "userSourceNameMap": {
    "contracts/MockMaliciousContract.sol": "project/contracts/MockMaliciousContract.sol",
    "contracts/ThreatDatabase.sol": "project/contracts/ThreatDatabase.sol",
    "contracts/Vigilant.sol": "project/contracts/Vigilant.sol"
  },
  "input": {
    "language": "Solidity",
    "settings": {
      "evmVersion": "shanghai",
      "optimizer": {
        "enabled": true,
        "runs": 200
      },
      "outputSelection": {
        "*": {
          "": [
            "ast"
          ],
          "*": [
            "abi",
            "evm.bytecode",
            "evm.deployedBytecode",
            "evm.methodIdentifiers",
            "metadata"
          ]
        }
      },
      "remappings": []
    },
    "sources": {
      "project/contracts/MockMaliciousContract.sol": {
        "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.20;\r\n\r\ncontract MockMaliciousAirdrop {\r\n    bool public claimActive = true;\r\n    address public attacker;\r\n    \r\n    constructor() {\r\n        attacker = msg.sender;\r\n    }\r\n    \r\n    // Looks safe in simulation\r\n    function claim() external {\r\n        if (claimActive) {\r\n            payable(msg.sender).transfer(0.0001 ether);\r\n        } else {\r\n            // Drains wallet if claimActive = false\r\n            uint256 balance = msg.sender.balance;\r\n            payable(attacker).call{value: balance}(\"\");\r\n        }\r\n    }\r\n    \r\n    // Attacker calls this to flip the switch\r\n    function flipSwitch() external {\r\n        require(msg.sender == attacker, \"Not attacker\");\r\n        claimActive = false;\r\n    }\r\n    \r\n    receive() external payable {}\r\n}"
      },
      "project/contracts/ThreatDatabase.sol": {
        "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.20;\r\n\r\ncontract ThreatDatabase {\r\n    struct ThreatReport {\r\n        address reporter;\r\n        address maliciousContract;\r\n        string threatType;\r\n        uint256 timestamp;\r\n        uint256 votes;\r\n    }\r\n    \r\n    mapping(address => ThreatReport[]) public reports;\r\n    mapping(address => bool) public isBlacklisted;\r\n    mapping(address => uint256) public threatScore; // 0-100\r\n    \r\n    event ThreatReported(\r\n        address indexed contract_,\r\n        address indexed reporter,\r\n        string threatType\r\n    );\r\n    \r\n    event ContractBlacklisted(address indexed contract_);\r\n    \r\n    function reportThreat(\r\n        address maliciousContract,\r\n        string calldata threatType\r\n    ) external {\r\n        reports[maliciousContract].push(ThreatReport({\r\n            reporter: msg.sender,\r\n            maliciousContract: maliciousContract,\r\n            threatType: threatType,\r\n            timestamp: block.timestamp,\r\n            votes: 1\r\n        }));\r\n        \r\n        // Increase threat score\r\n        threatScore[maliciousContract] += 10;\r\n        \r\n        // Auto-blacklist if score > 50\r\n        if (threatScore[maliciousContract] > 50) {\r\n            isBlacklisted[maliciousContract] = true;\r\n            emit ContractBlacklisted(maliciousContract);\r\n        }\r\n        \r\n        emit ThreatReported(maliciousContract, msg.sender, threatType);\r\n    }\r\n    \r\n    function getThreatScore(address contract_) external view returns (uint256) {\r\n        return threatScore[contract_];\r\n    }\r\n    \r\n    function getReports(address contract_) external view returns (ThreatReport[] memory) {\r\n        return reports[contract_];\r\n    }\r\n}"
      },
      "project/contracts/Vigilant.sol": {
        "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.20;\r\n\r\ncontract Vigilant {\r\n    // ========== STRUCTS ==========\r\n    \r\n    struct TransactionIntent {\r\n        address user;\r\n        address target;\r\n        bytes callData;\r\n        uint256 value;\r\n        uint256 timestamp;\r\n        uint256 deadline;\r\n        bool verified;\r\n        bool executed;\r\n        bytes32 stateSnapshot;\r\n    }\r\n    \r\n    struct SimulationResult {\r\n        address simulator;\r\n        bytes32 resultHash;\r\n        bool isRisky;\r\n        uint256 riskScore;\r\n        uint256 timestamp;\r\n    }\r\n    \r\n    // ========== STATE VARIABLES ==========\r\n    \r\n    mapping(bytes32 => TransactionIntent) public intents;\r\n    mapping(bytes32 => SimulationResult[]) public simulations;\r\n    mapping(bytes32 => bool) public stateChangeFlagged;\r\n    \r\n    // Simulator registry\r\n    mapping(address => uint256) public simulatorStakes;\r\n    mapping(address => uint256) public simulatorReputation;\r\n    uint256 public activeSimulators;\r\n    \r\n    // Insurance pool\r\n    uint256 public insurancePool;\r\n    \r\n    // Constants\r\n    uint256 public constant VERIFICATION_FEE = 0.001 ether;\r\n    uint256 public constant MIN_STAKE = 10 ether;\r\n    uint256 public constant SIMULATOR_REWARD = 0.00033 ether; // 0.001/3\r\n    \r\n    // ========== EVENTS ==========\r\n    \r\n    event IntentSubmitted(\r\n        bytes32 indexed intentId,\r\n        address indexed user,\r\n        address target,\r\n        uint256 timestamp\r\n    );\r\n    \r\n    event SimulationSubmitted(\r\n        bytes32 indexed intentId,\r\n        address indexed simulator,\r\n        bool isRisky,\r\n        uint256 riskScore\r\n    );\r\n    \r\n    event StateChangeDetected(\r\n        bytes32 indexed intentId,\r\n        address target,\r\n        uint256 timestamp\r\n    );\r\n    \r\n    event TransactionBlocked(\r\n        bytes32 indexed intentId,\r\n        string reason,\r\n        uint256 riskScore\r\n    );\r\n    \r\n    event TransactionExecuted(\r\n        bytes32 indexed intentId,\r\n        bool success,\r\n        uint256 riskScore\r\n    );\r\n    \r\n    event SimulatorRegistered(address indexed simulator, uint256 stake);\r\n    event SimulatorSlashed(address indexed simulator, uint256 amount);\r\n    \r\n    // ========== MODIFIERS ==========\r\n    \r\n    modifier onlyStakedSimulator() {\r\n        require(simulatorStakes[msg.sender] >= MIN_STAKE, \"Not staked simulator\");\r\n        _;\r\n    }\r\n    \r\n    // ========== SIMULATOR MANAGEMENT ==========\r\n    \r\n    function registerSimulator() external payable {\r\n        require(msg.value >= MIN_STAKE, \"Insufficient stake\");\r\n        require(simulatorStakes[msg.sender] == 0, \"Already registered\");\r\n        \r\n        simulatorStakes[msg.sender] = msg.value;\r\n        simulatorReputation[msg.sender] = 100; // Starting reputation\r\n        activeSimulators++;\r\n        \r\n        emit SimulatorRegistered(msg.sender, msg.value);\r\n    }\r\n    \r\n    function withdrawStake() external {\r\n        require(simulatorStakes[msg.sender] > 0, \"No stake\");\r\n        require(simulatorReputation[msg.sender] >= 50, \"Low reputation\");\r\n        \r\n        uint256 stake = simulatorStakes[msg.sender];\r\n        simulatorStakes[msg.sender] = 0;\r\n        activeSimulators--;\r\n        \r\n        payable(msg.sender).transfer(stake);\r\n    }\r\n    \r\n    // ========== INTENT SUBMISSION ==========\r\n    \r\n    function submitIntent(\r\n        address target,\r\n        bytes calldata data,\r\n        uint256 value\r\n    ) external payable returns (bytes32) {\r\n        require(msg.value >= value + VERIFICATION_FEE, \"Insufficient payment\");\r\n        require(activeSimulators >= 3, \"Not enough simulators\");\r\n        \r\n        bytes32 intentId = keccak256(abi.encodePacked(\r\n            msg.sender,\r\n            target,\r\n            data,\r\n            block.timestamp,\r\n            block.number\r\n        ));\r\n        \r\n        bytes32 stateSnapshot = captureStateSnapshot(target);\r\n        \r\n        intents[intentId] = TransactionIntent({\r\n            user: msg.sender,\r\n            target: target,\r\n            callData: data,\r\n            value: value,\r\n            timestamp: block.timestamp,\r\n            deadline: block.timestamp + 60, // 60 second deadline\r\n            verified: false,\r\n            executed: false,\r\n            stateSnapshot: stateSnapshot\r\n        });\r\n        \r\n        // 50% to insurance pool\r\n        insurancePool += VERIFICATION_FEE / 2;\r\n        \r\n        emit IntentSubmitted(intentId, msg.sender, target, block.timestamp);\r\n        \r\n        return intentId;\r\n    }\r\n    \r\n    function captureStateSnapshot(address target) internal view returns (bytes32) {\r\n        // Simple state snapshot (can be enhanced)\r\n        return keccak256(abi.encodePacked(\r\n            target.balance,\r\n            target.code.length,\r\n            blockhash(block.number - 1)\r\n        ));\r\n    }\r\n    \r\n    // ========== SIMULATION SUBMISSION ==========\r\n    \r\n    function submitSimulation(\r\n        bytes32 intentId,\r\n        bytes32 resultHash,\r\n        bool isRisky,\r\n        uint256 riskScore\r\n    ) external onlyStakedSimulator {\r\n        TransactionIntent memory intent = intents[intentId];\r\n        require(intent.user != address(0), \"Intent not found\");\r\n        require(block.timestamp <= intent.deadline, \"Intent expired\");\r\n        require(!intent.executed, \"Already executed\");\r\n        \r\n        // Check if simulator already submitted\r\n        SimulationResult[] memory existing = simulations[intentId];\r\n        for (uint i = 0; i < existing.length; i++) {\r\n            require(existing[i].simulator != msg.sender, \"Already submitted\");\r\n        }\r\n        \r\n        simulations[intentId].push(SimulationResult({\r\n            simulator: msg.sender,\r\n            resultHash: resultHash,\r\n            isRisky: isRisky,\r\n            riskScore: riskScore,\r\n            timestamp: block.timestamp\r\n        }));\r\n        \r\n        emit SimulationSubmitted(intentId, msg.sender, isRisky, riskScore);\r\n        \r\n        // Pay simulator immediately\r\n        payable(msg.sender).transfer(SIMULATOR_REWARD);\r\n        \r\n        // Increase reputation\r\n        simulatorReputation[msg.sender]++;\r\n    }\r\n    \r\n    // ========== STATE CHANGE FLAGGING ==========\r\n    \r\n    function flagStateChange(\r\n        bytes32 intentId,\r\n        address target\r\n    ) external {\r\n        require(intents[intentId].user != address(0), \"Intent not found\");\r\n        \r\n        stateChangeFlagged[intentId] = true;\r\n        \r\n        emit StateChangeDetected(intentId, target, block.timestamp);\r\n    }\r\n    \r\n    // ========== CONSENSUS CHECKING ==========\r\n    \r\n    function checkConsensus(bytes32 intentId) public view returns (\r\n        bool hasConsensus,\r\n        bool isSafe,\r\n        uint256 avgRiskScore\r\n    ) {\r\n        SimulationResult[] memory results = simulations[intentId];\r\n        \r\n        require(results.length >= 3, \"Need 3+ simulations\");\r\n        \r\n        // Count matching results\r\n        bytes32 majorityHash = results[0].resultHash;\r\n        uint256 matches = 0;\r\n        uint256 riskyCount = 0;\r\n        uint256 totalRiskScore = 0;\r\n        \r\n        for (uint i = 0; i < results.length; i++) {\r\n            if (results[i].resultHash == majorityHash) {\r\n                matches++;\r\n            }\r\n            if (results[i].isRisky) {\r\n                riskyCount++;\r\n            }\r\n            totalRiskScore += results[i].riskScore;\r\n        }\r\n        \r\n        avgRiskScore = totalRiskScore / results.length;\r\n        hasConsensus = (matches >= 2); // 2 out of 3\r\n        isSafe = (riskyCount < 2) && (avgRiskScore < 50);\r\n        \r\n        return (hasConsensus, isSafe, avgRiskScore);\r\n    }\r\n    \r\n    // ========== EXECUTION ==========\r\n    \r\n    function executeIntent(bytes32 intentId) external {\r\n        TransactionIntent storage intent = intents[intentId];\r\n        \r\n        require(msg.sender == intent.user, \"Not authorized\");\r\n        require(!intent.executed, \"Already executed\");\r\n        require(block.timestamp <= intent.deadline, \"Expired\");\r\n        \r\n        // Check consensus\r\n        (bool hasConsensus, bool isSafe, uint256 riskScore) = checkConsensus(intentId);\r\n        require(hasConsensus, \"No consensus yet\");\r\n        \r\n        // Check state changes\r\n        if (stateChangeFlagged[intentId]) {\r\n            bytes32 currentState = captureStateSnapshot(intent.target);\r\n            if (currentState != intent.stateSnapshot) {\r\n                emit TransactionBlocked(intentId, \"State changed\", riskScore);\r\n                revert(\"State changed - transaction blocked\");\r\n            }\r\n        }\r\n        \r\n        // Safety check\r\n        if (!isSafe || riskScore >= 50) {\r\n            emit TransactionBlocked(intentId, \"High risk detected\", riskScore);\r\n            \r\n            // Refund verification fee to user\r\n            payable(intent.user).transfer(VERIFICATION_FEE);\r\n            \r\n            revert(\"Transaction blocked - high risk\");\r\n        }\r\n        \r\n        // Execute transaction\r\n        intent.executed = true;\r\n        \r\n        (bool success, ) = intent.target.call{value: intent.value}(intent.callData);\r\n        \r\n        emit TransactionExecuted(intentId, success, riskScore);\r\n        \r\n        require(success, \"Execution failed\");\r\n    }\r\n    \r\n    // ========== SLASHING ==========\r\n    \r\n    function slashSimulator(address simulator) external {\r\n        // Simple automatic slashing (can enhance with governance)\r\n        require(simulatorReputation[simulator] < 30, \"Reputation too high\");\r\n        \r\n        uint256 slashAmount = simulatorStakes[simulator] / 10; // 10%\r\n        simulatorStakes[simulator] -= slashAmount;\r\n        \r\n        // Add to insurance pool\r\n        insurancePool += slashAmount;\r\n        \r\n        emit SimulatorSlashed(simulator, slashAmount);\r\n    }\r\n    \r\n    // ========== VIEW FUNCTIONS ==========\r\n    \r\n    function getIntent(bytes32 intentId) external view returns (TransactionIntent memory) {\r\n        return intents[intentId];\r\n    }\r\n    \r\n    function getSimulations(bytes32 intentId) external view returns (SimulationResult[] memory) {\r\n        return simulations[intentId];\r\n    }\r\n    \r\n    function getInsurancePool() external view returns (uint256) {\r\n        return insurancePool;\r\n    }\r\n}"
      }
    }
  }
}